\documentclass{itatnew}
%% !!!dolezite: ak pisete po slovensky alebo po cesky pouzite
%% \documentclass[slovensky]{itatnew}
%% \documentclass[cesky]{itatnew}

% Math shortcuts
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algorithmic}
\newcommand{\xx}{\mathrm{\mathbf{x}}}
\newcommand{\yy}{\mathrm{\mathbf{y}}}
\newcommand{\XX}{\mathrm{\mathbf{X}}}
\newcommand{\CC}{\mathrm{\mathbf{C}}}
\newcommand{\ttheta}{\mathbf{\theta}}
\newcommand{\eell}{\boldsymbol\ell}
% \newcommand{\msf}[1]{\mathsf{\mathbf{#1}}}

\begin{document}

\title{Sampling Methods for Model Guided Sampling Optimization
  with Gaussian Processes}

\author{Lukáš Bajer\inst{1,2} \and Martin Holeňa\inst{2}}

\institute{Faculty of Mathematics and Physics, Charles University in Prague,\\
Malostranske nam. 25, 118 00 Prague 1, Czech Republic\\
\email{bajer@cs.cas.cz} \\
\and
Institute of Computer Science, Academy of Sciences of the Czech Republic,\\
Pod Vodarenskou vezi 2, 182 07 Prague 8, Czech Republic\\
\email{martin@cs.cas.cz}}

\maketitle              % typeset the title of the contribution

\begin{abstract}
Model Guided Sampling Optimization (MGSO) was recently proposed as an alternative for Jones' Kriging-based EGO algorithm for optimization of expensive black-box functions. Instead of maximizing a chosen criterion (e.g. expected improvement), MGSO samples probability of improvement forming multiple candidates -- a whole population of suggested solutions. This paper tackles problems with such sampling, it compares different sampling methods and suggests further development of the MGSO algorithm.
\end{abstract}

\section{Introduction}
%
Optimization of expensive empirical functions forms an important topic in many engineering or natural-sciences areas. For such functions, it is often impossible to obtain any derivatives or information about smoothness; moreover, there is no mathematical expression nor algorithm to evaluate. Instead, some simulation or experiment has to be performed, and the measured value or result of such an experiment is the value of the objective function being considered. Such functions are also called black-box functions. 
% Such empirical functions 
They are usually very expensive to evaluate; one evaluation may cost a lot of time and money to process.

Because of the absence of the derivatives, standard continuous first- or second-order derivative optimization methods cannot be used. Further, functions of this kind are usually characterized by a high number of local optima where simple algorithms can be trapped easily. Therefore, different derivative-free optimization methods for black-box functions (often called meta-heuristics) have been evolved. Even though these methods are slow and computational intensive, the cost of the evaluation of the empirical objective function is always much higher, and so the number of function evaluations is crucial to decrease as much as possible.
% and the cost of these evaluations dominates the computational cost of the optimization algorithm.

Evolutionary algorithms \textbf{TODO-REF} constitute a broad family of meta-heuristics that are used for black-box optimization very frequently. Some kinds of these algorithms or some techniques are designed to spent for the optimization as few objective function evaluations as possible, all of the three following approaches use some kind of model being built and updated within the optimization process.

\emph{Estimation of distribution algorithms} (EDAs) \cite{larranaga_estimation_2002} represent one such approach: EDAs iteratively estimate probabilistic distribution of selected candidate solutions (usually better than some threshold) and sample this distribution forming a new set of solutions for the next iteration. 

\emph{Surrogate modelling} is a technique of construction and usage of a regression model of the objective function \textbf{TODO-REF}. The model (called surrogate model in this context) is then used to evaluate some of the candidate solutions instead of evaluating them with the original costly function.

Our method, \emph{Model Guided Sampling Optimization} (MGSO), is based on both these approaches. It is similar to Jones' Efficient Global Optimization (EGO)~\cite{jones_efficient_1998}: like EGO, MGSO uses a Gaussian process (GP, see~\cite{rasmussen_gaussian_2006} for reference), which provides a guide where to sample new candidate solutions in order to explore new solutions and exploit promising areas of the objective-function landscape. EGO evaluates a solution where a chosen criterion, Expected Improvement (EI) or Probability of Improvement (PoI) is maximized. On the other hand, MGSO samples GP model's latter criterion -- PoI, producing a set of new points. At the same time, the GP serves as a surrogate model of the objective function for some of the solutions. During each iteration, MGSO samples the model's PoI forming a population of new candidate solutions, evaluates them and updates the GP model with the new gathered data.

This paper follows up to the previous brief introduction of MGSO~\cite{bajer_model_2013}. Instead of Gibbs' sampling, it uses slice sampling algorithm introduced by Neal~\cite{neal_slice_2003} which enables computationally cheaper sampling in higher dimensions. Further, the GP model is used as a surrogate model more often which brings faster convergence. The following section introduces methods used in the MGSO, Section \ref{sec:mgso} describes the MGSO algorithm and the Section \ref{sec:results} brings some preliminary results on the BBOB testing set~\cite{hansen_real_2009}.


\section{Involved methods}

\subsection{Gaussian processes}

Gaussian process~\cite{rasmussen_gaussian_2006} is a probabilistic model based on Gaussian distributions. 
% It is specified by covariance and mean function and relatively small number of hyper-parameters. 
It is specified by mean and covariance functions and relatively small number of covariance function's hyper-parameters. 
% The hyper-parameters are set in such way that the likelihood of the function value given the values of the decision variables is maximized for the training data points.
The hyper-parameters are set by maximum-likelihood method.

The GP model can predict the function value in a new point in the form of univariate Gaussian distribution: the GP provides mean and standard deviation of the function value. Through the predicted mean, the GP can serve as a surrogate model, and standard deviation is a measure of uncertainty of the prediction in a specified point.

Let $\XX_N = \{\xx_i \ | \ \xx_i \in \mathbb{R}^{D}\}_{i=1}^{N}$ be a set of $N$ training data points with known dependent-variable values $\yy = \{y_i\}_{i=1}^{N}$ and $f(\xx)$ be an unknown function being modelled for which $f(\xx_i) = y_i$ for all $i \in \{1,\ldots,N\}$. The GP model imposes a probabilistic model on the data: the vector of known function values $\yy_N$ is considered as one sample of a $N$-dimensional multivariate Gaussian distribution with probability density $p(\yy \, | \, \XX_N)$. If we add a new data point $(\xx_{N+1}, y_{N+1})$, the probability density is, according to B\"{u}che \cite{buche_accelerating_2005},
\begin{equation}
p(\yy_{N+1} \, | \, \XX_{N+1}) = \frac { \exp(-\frac{1}{2} \yy^\top_{N+1} \CC^{-1}_{N+1} \yy_{N+1}) } { \sqrt{(2\pi)^{N+1} \det(\CC_{N+1})} }
\end{equation}
where $\CC_{N+1}$ is the covariance matrix of the Gaussian distribution (for which mean is usually set to constant zero). This covariance can be written as
\begin{equation}
\CC_{N+1} = \left( \begin{array}{cc} \CC_N & \mathbf{k} \\ \mathbf{k}^\top & \kappa \end{array} \right)
\end{equation}
where $\CC_N$ is the covariance of the Gaussian distribution given the $N$ training data points, $\mathbf{k}$ is a vector containing covariances between the new point and training data, and $\kappa$ is the variance of the new point itself. Further, inverse $\CC^{-1}_{N-1}$ of the extended covariance can be expressed using inverse of the training covariance $\CC^{-1}_N$ which simplifies density of the distribution in a new point to a univariate Gaussian with density
\begin{equation}
p(y_{N+1} \, | \, \XX_{N+1}, \yy_N) \ \varpropto \ \exp \left( -\frac{1}{2} \frac {(y_{N+1} - \hat{y}_{N+1})^2} {\sigma^2_{y_{N+1}}} \right)
\label{univariate-density}.
\end{equation}
with mean and variance given by
\begin{eqnarray}
\hat{y}_{N+1} & = & \mathbf{k}^\top \CC^{-1}_N \yy_N, \\
\sigma^2_{y_{N+1}} & = & \kappa - \mathbf{k}^\top \CC^{-1}_N \mathbf{k}.
\end{eqnarray}
Further details can be found in \cite{buche_accelerating_2005}.

The covariances $\CC_N$ plays a crucial role in these equations. Gaussian processes use parametrized covariance functions $C$ describing prior assumptions on the shape of the modeled function. The covariance between the function values at two data points $\xx_p$ and $\xx_q$ is given by $C(\xx_p, \xx_q)$ which forms also the $(p,q)$-th element of the matrix $\CC_N$. In our case, we used the most common squared-exponential function
\begin{equation}
C(\xx_p, \xx_q) = \theta_1 \exp \left( -\frac{1}{2} \sum^D_{i=1} \frac{(x^i_p - x^i_q)^2} {2l^2} \right) + \theta_2 + \delta_{p,q}\theta_3
\end{equation}
which is suitable when the modelled function is rather smooth. The closer the points $\xx_p$ and $\xx_q$ are, the closer the covariance function value is to 1 and the stronger correlation between function values $f(\xx_p)$ and $f(\xx_q)$ is. The hyper-parameter $\theta_1$ scales this correlation, $\theta_2$ rises the value from zero and $\theta_3$ means a white noise of the diagonal elements of the matrix. The last parameter $l$ is the length-scale with which the distance of two considered data points is compared. Estimate of these hyper-parameters can be supplied by the user and the final value is usually learnt using maximum-likelihood approach.


\subsection{Sampling}

The core of the MGSO algorithm is made by sampling of the probability of improvement. This measure is, for a chosen threshold $T$ of the function value, directly given by the predicted mean $\hat{f}(\xx) = \hat{y}$ and the standard deviation $\hat{\sigma}(\xx) = \sigma_{y}$ of the GP model $\hat{f}$ in any point $\xx$ of the input space
\begin{equation}
  \mathrm{PoI}_T(\xx) = \mathrm{\Phi}\left( \frac{T - \hat{f}(\xx)}{\hat{\sigma}(\xx)} \right) = \mathrm{P}(\hat{f}(\xx) \leqq T)
\end{equation}
which corresponds to the value of cumulative distribution function (CDF) of the Gaussian with already mentioned density (\ref{univariate-density}). Even though all the variables come from Gaussian distribution, $\mathrm{PoI}(\xx)$ is definitely not Gaussian-shaped since it depends on the threshold $T$ and the function being modeled $f$ -- typical example of the landscape of $\textrm{PoI}(\xx)$ in two dimensions for Rastrigin function is depicted in Fig.\,1 % THIS DOES NOT WORK :( \ref{fig:poi}.
The dependency on the modelled function causes also no analytical marginals, derivatives or conditional probabilities of this density.

\begin{figure}
  \centering
  \includegraphics[width=0.6\linewidth]{poi_example}
  {\small
  \caption{Probability of improvement. Rastrigin function in 2D, GP model built with 40 data points.}
  }
  \label{fig:poi}
\end{figure}

\paragraph{Gibbs' sampler.}

The first version of MGSO~\cite{bajer_model_2013} used Gibbs' sampler~\cite{geman_stochastic_1984}. The sampler starts at some point of the input space $\xx_s$. Further, it moves along each dimension to a new point $\xx'$: it cycle successively through each individual dimension $k = 1,\ldots,D$ by assessing its value through sampling from conditional probability of this variable given values of the remaining ones: for $k=1,\ldots,D$
\begin{equation}
X^k \sim p(X^k \, | \, \{X^j = x^j, j \neq k)\}).
\end{equation}
As no analytical expression for these conditionals exists, inverse of the empirical conditional CDF's $F^{-1}_k$ was used to transform samples from uniform distributions
\begin{displaymath}
u^k \sim U(0,1), \quad  x^k = F^{-1}_k(u_k).
\end{displaymath}
Linear interpolation between 20-points grid of empirical CDF was used.

Even though evaluating GP model's mean $\hat{y} = \hat{f}(\xx)$ and standard deviation $\hat{\sigma}(\xx)$ for 20 points requires only two calls of GP model prediction, the complexity of sampling rises quickly with number of variables $D$ which causes sampling in more than three dimensions being extremely slow.

\paragraph{Slice sampling.}

\begin{algorithm}[b]
\begin{algorithmic}[1]
{\small
\STATE \textbf{Input}: $f$ -- function proportional to the density \\
  \quad $\xx_0$ -- starting point, $\xx_0 \in \mathbb{R}^D$ \\
  \quad $\mathbf{w}$ -- scale estimates, $\mathbf{w} \in \mathbb{R}^D$ \\
  \quad $n$ -- required number of samples
\FOR {$k = 0,1,\ldots,n$}
  % \STATE \COMMENT{define the slice} \\
  \STATE $y \sim U(0, \, f(\xx_k))$  \hspace{\fill}  \COMMENT{height of the slice}
  % \STATE \COMMENT{random position of the hyper-rectangle} \\
  \STATE $\mathbf{u} \sim U(0,1)^D$ %  \hspace{\fill}  \COMMENT{random shift of hyper-rectangle}
  \STATE $\mathbf{L} \leftarrow \xx_k - \mathbf{w} \circ \mathbf{u}$  \hspace{\fill}  \COMMENT{randomly shifted lower bound} % \COMMENT{$\circ$ is entrywise product}
  \STATE $\mathbf{R} \leftarrow \mathbf{L} + \mathbf{w}$   \hspace{\fill}  \COMMENT{upper bound}
  % \STATE $\mathbf{L},\mathbf{R} \leftarrow$ lower/upper bounds of a hyper-rectangle $\mathbf{H}$ \\
  % \quad $\xx_k \in \mathbf{H}, \quad R_j - L_j = w_j \ \forall j = 1,\ldots,D$
  \WHILE {given number of tries has not exceeded}
    \STATE $\mathbf{u} \sim U(0,1)^D$
    \STATE $\xx_{k+1} \leftarrow \mathbf{L} + \mathbf{u} \circ (\mathbf{R} - \mathbf{L})$ \hspace{\fill}  \COMMENT{$\xx_{k+1} \sim U(\mathbf{L},\mathbf{R})^D$}
    % \STATE $\xx_{k+1} \leftarrow$ random sample from the hyper-rectangle $[\mathbf{L}, \mathbf{R}]$
    \IF {$(y < f(\xx_{k+1}))$}
      \STATE accept $\xx_{k+1}$ and exit the \emph{while} loop
    \ENDIF
    \FOR {each dimension $j = 1,\ldots,D$}
      \IF {$(x^j_{k+1} < x^j_k)$}
      \STATE $L^j \leftarrow x^j_{k+1}$  \hspace{\fill}  \COMMENT{shrink the lower bound}
      \ELSE
      \STATE $R^j \leftarrow x^j_{k+1}$  \hspace{\fill}  \COMMENT{shrink the upper bound}
      \ENDIF
    \ENDFOR
  \ENDWHILE
\ENDFOR
\STATE \textbf{Output}: $\{\xx_1,\ldots,\xx_n\}$
}
\end{algorithmic}
\caption{Slice sampling~\cite{neal_slice_2003}}
\label{alg:slice}
\end{algorithm}

This novel kind of sampling brought by Neal~\cite{neal_slice_2003} is based on a simple and smart idea. It starts from a starting point $(\xx_0, f(\xx_0))$ where a uniform sample $y \sim U(0,f(\xx_0))$ is obtained. This number induces a subspace $S=\{\xx\,|\,f(\xx) > y\}$ which is quickly approximated and uniformly sampled, forming the next point $\xx_1$. The approximation of the subspace is dependent on the only parameter of this method, scale estimate $\mathbf{w} \in \mathbb{R}^D$, which is even not crucial for speed nor convergence.

Slice sampling has several advantages. First, it nicely scales with higher dimensionality of the problem. Second, there is no need of conditional distributions as it is with Gibbs' sampler. Moreover, it does not require the density being normalized, function proportional to the density is sufficient (which is also the case of PoI). The pseudo-code of this method is described in Alg.\,\ref{alg:slice}. This sampler is used in the second version of MGSO, described in this paper.


\section{Model Guided Sampling Optimization}
\label{sec:mgso}

As was already mentioned, the MGSO algorithm for black-box optimization has many common aspects with Jones'~\cite{jones_efficient_1998} efficient global optimization algorithm. Like some of the versions of EGO, it uses probability of improvement as a measure how promising is specified point for locating optimum given the current knowledge of the function landscape saved in the dataset and modelled by the GP. The main difference is that it does not maximizes this criterion, but it samples this function (proportional to density) producing the whole population of individuals. 


\begin{algorithm}[t]
\begin{algorithmic}[1]
{\small
  \STATE \textbf{Input}: $f$ -- objective function \\
      \quad $N', N$ -- sizes of the initial and standard population \\
      \quad $N_N$ -- no. of individuals for dataset restriction
  \STATE $\mathsf{S}_0 = \{(\xx_j, y_j)\}_{j=1}^{N'} \leftarrow$ generate $N'$ initial samples 
      and evaluate them % to get observed values $\{y_j\}_{j=1}^{N'}$ forming a dataset $\mathsf{S}_0 = \{(\xx_0, y_0)\}$
  \WHILE {no stopping condition is met, $i=1,2,\ldots$}
    \STATE $\mathsf{M}_i \leftarrow$ build a GP model and fit its hyper-parameters
        according to the dataset $\mathsf{S}_{i-1}$
    \STATE $\{\xx_j\}_{j=1}^N  \leftarrow$ sample $N$ new candidate solutions based
        on the PoI distribution of $\mathsf{M}_i$, optionally with
        different targets $T$
    \STATE $\{y_j\}_{j=1}^N \leftarrow f(\{\xx_j\}_{j=1}^N)$  \hspace{\fill}  \COMMENT{evaluate the population} 
    \STATE $\mathsf{S}_i \leftarrow \mathsf{S}_{i-1} \cup \{(\xx_j, y_j)\}_{j=1}^N$  \hspace{\fill}  \COMMENT{augment the dataset} 
    \STATE $(\tilde{\xx}, \tilde{y}) \leftarrow \arg \min_{(\xx,y) \in \mathsf{S}_i} y$  \hspace{\fill}  \COMMENT{find the best solution}
    \IF {any rescale condition is met} 
    \STATE restrict the dataset $\mathsf{S}_i$ according to the $N_N$ nearest solutions to $(\tilde{\xx},\tilde{y})$ and transform $\mathsf{S}_i$ to $[-1, 1]^D$
    \ENDIF
  \ENDWHILE
  \STATE \textbf{Output}: the best found solution $(\tilde{\xx}, \tilde{y})$
}
\end{algorithmic}
\caption{MGSO (Model Guided Sampling Optimization}
\label{alg:mgso}
\end{algorithm}

\section{Experimental results and conclusion}
\label{sec:results}



% \noindent ==================
% 
% Evolutionary algorithms evolve in parallel a set of candidate solutions (a population) in multiple steps. Every iteration (in evolutionary context called generation) the candidate solutions (individuals) are evaluated with the objective function (so called fitness function). Then, some of these individuals are selected; the better ones are preferred. Finally, the selected individuals are modified or recombined between each other, a new population is created and a new generation starts again.
% 
% \paragraph{Surrogate Modelling.}
% Approximation of the fitness function with some regression model is a common cure for tasks when empirical objective function has to be used. These \textit{surrogate models} simulate behaviour of the original function while being much cheaper and much less time consuming to evaluate. As a surrogate model, any suitable regression model can be used~\cite{hosder2001polynomial,buche2005accelerating,ulmer2005model}.
% 
% In connection with evolutionary optimization, artificial neural networks of the type multilayer perceptrons \cite{jin2005neural} and networks with radial basis functions \cite{zhou2007combining,ong2004surrogate} have been particularly popular. The last mentioned kind of neural networks underlies also the model reported in this paper.





\subsection*{Acknowledgments}

This work was supported by the Czech Science Foundation (GA\v{C}R) grants \hbox{P202/11/1368} and \hbox{13-17187S}, and the Grant Agency of the Charles University (GAUK) \hbox{278511/2011} grant. 

%
% ---- Bibliography ----
%
\bibliography{bajer2013itat}  % sigproc.bib is the name of the Bibliography in this case
\bibliographystyle{abbrv}

% %
% \begin{thebibliography}{5}
% %
% \bibitem {clar:eke}
% Clarke, F., Ekeland, I.:
% Nonlinear oscillations and
% boundary-value problems for Hamiltonian systems.
% Arch. Rat. Mech. Anal. {\bf 78} (1982) 315--333
% 
% \bibitem {clar:eke:2}
% Clarke, F., Ekeland, I.:
% Solutions p\'{e}riodiques, du
% p\'{e}riode donn\'{e}e, des \'{e}quations hamiltoniennes.
% Note CRAS Paris {\bf 287} (1978) 1013--1015
% 
% \bibitem {mich:tar}
% Michalek, R., Tarantello, G.:
% Subharmonic solutions with prescribed minimal
% period for nonautonomous Hamiltonian systems.
% J. Diff. Eq. {\bf 72} (1988) 28--55
% 
% \bibitem {tar}
% Tarantello, G.:
% Subharmonic solutions for Hamiltonian
% systems via a $\bbbz_{p}$ pseudoindex theory.
% Annali di Matematica Pura (to appear)
% 
% \bibitem {rab}
% Rabinowitz, P.:
% On subharmonic solutions of a Hamiltonian system.
% Comm. Pure Appl. Math. {\bf 33} (1980) 609--633
% 
% \end{thebibliography}

\end{document}
